questionType,contentType,contentBody,intAnswer,prepTime(in_seconds),floatAnswer.max,floatAnswer.min,fitbAnswer,mcscAnswer,subjectiveAnswer,option.1,option.2,option.3,option.4,mcmcAnswer,tagRelationships,difficultyLevel,answerExplanation
mcsc,markdown,"A junior developer is building a feature to track unique visitor IPs for a daily report. The current implementation uses a list and checks for existence before adding:

```python
visitor_ips = []
# ... inside a loop processing millions of requests ...
if ip_address not in visitor_ips:
    visitor_ips.append(ip_address)
```

Performance is degrading as the list grows. Which refactoring provides the most appropriate logical model for storing *only* unique items?",,,,,,3,,Convert `visitor_ips` to a Tuple to save memory,Use a Dictionary with IPs as values and incrementing integers as keys,"Use a Set, which automatically handles uniqueness and ignores duplicates",Sort the list after every insertion to make the search faster,,,0.5,"A Set (Option 3) is designed specifically as an unordered collection of unique elements. It automatically handles uniqueness (adding a duplicate has no effect), removing the need for the manual `if not in` check and providing a more semantically correct structure for this problem. Tuples (Option 1) allow duplicates. Dictionaries (Option 2) enforce unique keys, not values, and using IPs as values wouldn't solve the uniqueness constraint efficiently."
mcsc,markdown,"During a code review of a budget application, you encounter the following function intended to reset the user's budget:

```python
current_budget = 100.00

def reset_budget():
    current_budget = 500.00
    print(f""Budget reset to {current_budget}"")

reset_budget()
print(f""Main program sees: {current_budget}"")
```

The output shows:
`Budget reset to 500.0`
`Main program sees: 100.0`

Why did the variable fail to update in the main program?",,,,,,1,,The function created a local variable named `current_budget` that shadowed the global one,Global variables are immutable in Python and cannot be changed,The developer forgot to return the value using the `yield` keyword,The floating point format caused a precision error preventing the update,,,0.5,"This is a scope issue. Inside `reset_budget`, assigning a value to `current_budget` creates a new *local* variable specific to that function, shadowing the global variable of the same name. The global variable remains untouched. To modify the global variable, the `global` keyword would be required, though passing parameters and returning values is the recommended best practice."
mcsc,markdown,"An automated test for your inventory system is failing with an `IndexError`. The system manages a list of items currently in a user's cart.

**Code Snippet:**
```python
cart = [""Apple"", ""Banana"", ""Milk""]
print(f""Removing last item: {cart[3]}"")
```

**Context:**
- The list has 3 items.
- The developer assumed the last item is at index 3 because the length is 3.

What is the root cause of this error?",,,,,,3,,"Lists in Python are immutable, so accessing them for removal throws an error",The list has not been initialized properly,"Python uses zero-based indexing, so the valid indices are 0, 1, and 2",The list contains mixed data types which prevents indexing,,,0.3,"Python uses zero-based indexing. For a list with 3 elements, the elements are at indices 0, 1, and 2. Accessing index 3 tries to access a 4th element, which does not exist, triggering an `IndexError`. Option 1 is incorrect because lists are mutable. Option 4 is incorrect because lists support mixed types."
mcsc,markdown,An application processes a high-frequency stream of user IDs and needs to check if a specific ID has already been processed to avoid redundant calculations. Which data structure provides the most efficient average-case time complexity for this 'membership check'?,,,,,,3,,"A List, because it maintains the chronological order of IDs.","A Sorted List, because it allows for O(log n) binary search lookups.","A Set, because it uses a hash table to provide O(1) average lookup time.","A Tuple, because its immutability prevents the IDs from being modified during the check.",,,0.4,"Sets are implemented using hash tables, making membership tests (the 'in' operator) extremely fast (O(1) on average), regardless of the number of elements. Lists and tuples require O(n) time to search."
mcsc,markdown,"A developer writes a function to clean a list of names by removing whitespace. They use the following code:

```python
def clean_names(data):
    backup = data
    backup.append('Cleaned')
    return backup

names = [' Alice', 'Bob ']
new_names = clean_names(names)
```

After running this, the developer notices that the original `names` list also contains the string 'Cleaned'. Why did this happen?",,,,,,2,,"Lists are immutable, so Python automatically updates all references to the object.","The assignment `backup = data` creates a new reference to the same list object in memory, not a copy.","The `.append()` method always returns a new list, which was then reassigned to the global scope.","Python functions pass lists by value, but the `return` statement forces a merge of the two scopes.",,,0.6,"In Python, assigning one list variable to another (`backup = data`) does not copy the list; it creates a second reference to the same object. Modifications to one will be reflected in the other. To create a copy, one should use `data.copy()` or `data[:]`."
mcmc,markdown,"A developer is designing a system to store fixed geographical coordinates (latitude, longitude) for a series of weather stations. These pairs should remain constant once defined to prevent data corruption. Which of the following are valid reasons to store each coordinate pair as a tuple rather than a list?",,,,,,,,"Tuples are immutable, ensuring that a coordinate pair like (40.71, -74.00) cannot be accidentally changed to (40.71, -75.00).","Tuples are generally more memory-efficient than lists, which is beneficial when storing millions of coordinate points.","Tuples can be used as keys in a dictionary, allowing the developer to map specific coordinates to station names.","Tuples provide the .sort() method, which allows the developer to reorder the internal latitude and longitude values in-place.","1, 2, 3",,0.6,"Tuples are immutable, making them safer for data that shouldn't change and allowing them to be hashable (usable as dict keys). They also have a smaller memory footprint than lists. Option 4 is incorrect because tuples do not have in-place modification methods like .sort()."
mcmc,markdown,"A data analyst has a list of sensor readings: `readings = [10.2, 11.5, 12.1, 9.8, 10.5, 11.2]`. They need to extract a sub-list containing every second reading starting from the first element (index 0). Which of the following slicing operations will correctly produce `[10.2, 12.1, 10.5]`?",,,,,,,,readings[::2],readings[0:len(readings):2],readings[0:-1:2],readings[1::2],"1, 2",,0.5,"Option 1 uses the default start and end with a step of 2. Option 2 explicitly defines the start (0) and end (length of list) with a step of 2. Option 3 is incorrect because the stop index -1 excludes the last element of the list. Option 4 starts at index 1, which would return the wrong values."
mcmc,markdown,"A developer needs to update a configuration dictionary `config = {'timeout': 30, 'retry': True}` with new values from `updates = {'timeout': 60, 'version': '1.2'}`. Which of the following approaches will successfully merge the updates into the original `config` dictionary?",,,,,,,,config.update(updates),"config = {**config, **updates}",config = config + updates,"for key, value in updates.items(): config[key] = value","1, 2, 4",,0.7,"The .update() method (Option 1), dictionary unpacking (Option 2), and manual iteration (Option 4) are all valid ways to merge dictionaries. Option 3 is incorrect because the '+' operator is not supported for dictionaries in Python."
subjective,markdown,"Consider the following Python code snippet intended to track the total cost of a shopping cart:

```python
total_cost = 0

def add_item(price):
    total_cost = total_cost + price
    print(f""Added item. Total is now: {total_cost}"")

add_item(50)
```

Running this code results in an `UnboundLocalError`.

**Based on the transcript's explanation of scope:**
1. Explain WHY this error occurs.
2. Provide the corrected code using the transcript's recommended 'Best Practice' (hint: do NOT just add the `global` keyword).",,,,,,,"**1. Explanation:** The error occurs because inside `add_item`, the line `total_cost = ...` tells Python to treat `total_cost` as a local variable. However, it tries to read the value of `total_cost` before it has been assigned a value in that local scope. It does not automatically look up the global variable because it is being assigned to.

**2. Corrected Code (Best Practice):**
The best practice is to avoid global variables and use parameters and return values:

```python
total_cost = 0

def add_item(current_total, price):
    return current_total + price

total_cost = add_item(total_cost, 50)
# total_cost is now updated via the return value
print(f""Added item. Total is now: {total_cost}"")
```",,,,,,,1,"The answer should identify that modifying a variable inside a function makes it local by default unless `global` is used. However, best practice explicitly recommends avoiding global variables and using function parameters and return values for data flow."
subjective,markdown,"In a scenario where you are building a real-time leaderboard for an online game, you need to store players' unique usernames and their current scores. You must be able to: 1) Update a player's score instantly using their username, and 2) Ensure that no duplicate usernames exist in the system. 

Describe the most appropriate Python data collection for this requirement and justify your choice based on performance and the specific constraints provided.",,,,,,,"The most appropriate data structure is a Dictionary. A dictionary maps unique keys (usernames) to values (scores). This satisfies the requirement for uniqueness because dictionary keys must be unique; adding a duplicate key simply updates the existing value. Furthermore, dictionaries provide O(1) average time complexity for both looking up and updating a player's score by their username, which is essential for a real-time system.",,,,,,,0.5,"Dictionaries are the ideal choice here because they enforce key uniqueness and provide near-instantaneous access/updates via hashing, fulfilling both the 'unique username' and 'instant update' requirements."